import os
import struct
import subprocess
import csv
import tempfile
from typing import List, Optional, Dict

# Handle both module and direct execution
try:
    from .crypto_utils import hash160, base58check_encode, bech32_encode
except ImportError:
    from crypto_utils import hash160, base58check_encode, bech32_encode

# Bitcoin network configurations
NETWORKS = {
    'mainnet': {
        'p2pkh_version': 0x00,
        'p2sh_version': 0x05,
        'bech32_hrp': 'bc',
        'name': 'mainnet'
    },
    'testnet': {
        'p2pkh_version': 0x6f,
        'p2sh_version': 0xc4,
        'bech32_hrp': 'tb',
        'name': 'testnet'
    },
    'regtest': {
        'p2pkh_version': 0x6f,
        'p2sh_version': 0xc4,
        'bech32_hrp': 'bcrt',
        'name': 'regtest'
    },
    'signet': {
        'p2pkh_version': 0x6f,
        'p2sh_version': 0xc4,
        'bech32_hrp': 'tb',
        'name': 'signet'
    }
}

def detect_network_from_path(path: str) -> str:
    """
    Detect Bitcoin network from chainstate path.
    
    Args:
        path: Path to chainstate directory or parent directory
        
    Returns:
        Network name ('mainnet', 'testnet', 'regtest', 'signet')
    """
    path_lower = path.lower()
    
    # Check path components for network indicators
    parts = os.path.normpath(path).split(os.sep)
    for part in parts:
        part_lower = part.lower()
        if part_lower == 'testnet3':
            return 'testnet'
        elif part_lower == 'regtest':
            return 'regtest'
        elif part_lower == 'signet':
            return 'signet'
        elif part_lower == 'testnet':
            return 'testnet'
    
    # Default to mainnet
    return 'mainnet'

class BalanceChecker:
    def __init__(self, data_path=None):
        self.data_path = data_path
        self.funded_addresses = set()
        self.address_balances = {}
        self.is_loaded = False
        self.db = None
        self.debug_mode = False
        self.debug_messages = []
        self.network = 'mainnet'

    def enable_debug(self, enabled=True):
        """
        Enable or disable debug mode.
        
        When enabled, debug messages are printed to console and stored internally.
        This is useful for troubleshooting chainstate loading and address extraction.
        
        Args:
            enabled: True to enable debug mode, False to disable (default: True)
        """
        self.debug_mode = enabled
        if enabled:
            print("[DEBUG] Debug mode enabled")
        else:
            print("[DEBUG] Debug mode disabled")

    def set_network(self, network: str):
        """
        Set the Bitcoin network for address encoding.
        
        This is useful when loading addresses from a file rather than
        Bitcoin Core chainstate, where network detection isn't possible.
        
        Args:
            network: Network name ('mainnet', 'testnet', 'regtest', 'signet')
        
        Raises:
            ValueError: If network name is not recognized
        """
        if network not in NETWORKS:
            raise ValueError(f"Unknown network '{network}'. Valid networks: {list(NETWORKS.keys())}")
        self.network = network
        self._debug(f"Network set to: {network}")

    def get_network(self) -> str:
        """Get the current network."""
        return self.network

    def _debug(self, message):
        """Add debug message if debug mode is enabled."""
        if self.debug_mode:
            self.debug_messages.append(message)
            print(f"[DEBUG] {message}")

    def get_debug_messages(self):
        """Retrieve all debug messages."""
        messages = self.debug_messages.copy()
        self.debug_messages.clear()
        return messages

    def load_addresses(self, filepath):
        """Load funded addresses from a text file or binary dump."""
        if not os.path.exists(filepath):
            return False
        
        try:
            with open(filepath, 'r') as f:
                for line in f:
                    addr = line.strip()
                    if addr:
                        self.funded_addresses.add(addr)
            self.is_loaded = True
            return True
        except Exception:
            return False

    def load_from_csv(self, filepath: str, address_column: str = 'address', balance_column: str = 'balance') -> bool:
        """
        Load addresses and balances from a CSV file.
        
        This method is particularly useful for loading CSV files generated by
        btcposbal2csv or similar tools that export addresses with balances.
        
        Args:
            filepath: Path to the CSV file
            address_column: Name of the column containing addresses (default: 'address')
            balance_column: Name of the column containing balances (default: 'balance')
        
        Returns:
            True if successful, False otherwise
        
        Example CSV format:
            address,balance
            1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa,5000000000
            bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh,100000
        """
        if not os.path.exists(filepath):
            self._debug(f"CSV file not found: {filepath}")
            return False
        
        try:
            address_balances = {}
            with open(filepath, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                
                # Check if required columns exist
                if reader.fieldnames is None:
                    self._debug("CSV file has no header row")
                    return False
                
                if address_column not in reader.fieldnames:
                    self._debug(f"Column '{address_column}' not found in CSV. Available columns: {reader.fieldnames}")
                    return False
                
                # Balance column is optional
                has_balance = balance_column in reader.fieldnames
                
                for row_num, row in enumerate(reader, start=2):  # Start at 2 because of header
                    try:
                        address = row.get(address_column, '').strip()
                        if not address:
                            continue
                        
                        if has_balance:
                            balance_str = row.get(balance_column, '0').strip()
                            # Remove any commas or spaces from balance
                            balance_str = balance_str.replace(',', '').replace(' ', '')
                            try:
                                balance = int(float(balance_str))
                            except (ValueError, TypeError):
                                self._debug(f"Row {row_num}: Invalid balance value '{balance_str}', using 0")
                                balance = 0
                        else:
                            balance = 1  # Presence-only mode
                        
                        address_balances[address] = balance
                        
                    except Exception as e:
                        self._debug(f"Row {row_num}: Error parsing row: {e}")
                        continue
            
            if not address_balances:
                self._debug("No valid addresses found in CSV file")
                return False
            
            self.address_balances = address_balances
            self.data_path = filepath
            self.is_loaded = True
            
            self._debug(f"Loaded {len(address_balances)} addresses from CSV: {filepath}")
            print(f"Loaded {len(address_balances)} addresses from CSV")
            return True
            
        except Exception as e:
            self._debug(f"Error loading CSV file: {e}")
            print(f"Failed to load CSV file: {e}")
            return False

    def extract_addresses_with_btcposbal2csv(
        self,
        chainstate_path: str = None,
        output_csv: str = None,
        btcposbal2csv_path: str = 'btcposbal2csv'
    ) -> bool:
        """
        Extract addresses with positive balances using btcposbal2csv tool.
        
        This method runs the btcposbal2csv command-line tool to extract addresses
        from Bitcoin Core's chainstate database and export them to a CSV file.
        
        btcposbal2csv is a high-performance tool (written in C++) that can quickly
        extract all addresses with positive balances from the chainstate LevelDB.
        
        Installation:
            git clone https://github.com/graymauser/btcposbal2csv
            cd btcposbal2csv
            make
            # Then ensure btcposbal2csv is in PATH or provide full path
        
        Args:
            chainstate_path: Path to Bitcoin Core chainstate directory
                           If None, auto-detects using get_bitcoin_core_db_path()
            output_csv: Path where to save the CSV file
                       If None, creates a temporary file
            btcposbal2csv_path: Path to btcposbal2csv executable (default: 'btcposbal2csv')
        
        Returns:
            True if extraction successful and CSV loaded, False otherwise
        
        Example:
            checker = BalanceChecker()
            if checker.extract_addresses_with_btcposbal2csv():
                print(f"Loaded {len(checker.address_balances)} addresses")
        """
        # Auto-detect chainstate path if not provided
        if chainstate_path is None:
            candidates = self.get_bitcoin_core_db_paths()
            if not candidates:
                self._debug("No Bitcoin Core chainstate found")
                print("Bitcoin Core chainstate not found. Please specify chainstate_path.")
                return False
            chainstate_path = candidates[0]
            self._debug(f"Auto-detected chainstate path: {chainstate_path}")
        
        # Validate chainstate path
        if not os.path.exists(chainstate_path):
            self._debug(f"Chainstate path does not exist: {chainstate_path}")
            print(f"Chainstate path not found: {chainstate_path}")
            return False
        
        # Detect network from path
        self.network = detect_network_from_path(chainstate_path)
        self._debug(f"Detected network: {self.network}")
        
        # Create output CSV path if not provided
        temp_file = None
        if output_csv is None:
            temp_file = tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False)
            output_csv = temp_file.name
            temp_file.close()
            self._debug(f"Using temporary file: {output_csv}")
        
        try:
            # Check if btcposbal2csv is available
            try:
                version_check = subprocess.run(
                    [btcposbal2csv_path, '-h'],
                    capture_output=True,
                    timeout=5
                )
                if version_check.returncode not in [0, 1]:  # Some tools return 1 for help
                    self._debug(f"btcposbal2csv not found or not executable: {btcposbal2csv_path}")
                    print(f"btcposbal2csv not found. Please install it from https://github.com/graymauser/btcposbal2csv")
                    return False
            except (subprocess.TimeoutExpired, FileNotFoundError) as e:
                self._debug(f"btcposbal2csv check failed: {e}")
                print(f"btcposbal2csv not found. Please install it from https://github.com/graymauser/btcposbal2csv")
                return False
            
            # Get parent directory of chainstate (Bitcoin Core data directory)
            bitcoin_datadir = os.path.dirname(chainstate_path)
            
            # Run btcposbal2csv
            self._debug(f"Running btcposbal2csv on {bitcoin_datadir}")
            print(f"Extracting addresses from {bitcoin_datadir}...")
            print("This may take a few minutes depending on UTXO set size...")
            
            # btcposbal2csv typically expects the Bitcoin data directory as argument
            # and outputs to stdout or a specified file
            cmd = [btcposbal2csv_path, bitcoin_datadir, output_csv]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600  # 10 minute timeout
            )
            
            if result.returncode != 0:
                self._debug(f"btcposbal2csv failed with return code {result.returncode}")
                self._debug(f"stdout: {result.stdout}")
                self._debug(f"stderr: {result.stderr}")
                print(f"btcposbal2csv extraction failed: {result.stderr}")
                return False
            
            self._debug(f"btcposbal2csv completed successfully")
            self._debug(f"Output: {result.stdout}")
            
            # Check if output file was created
            if not os.path.exists(output_csv) or os.path.getsize(output_csv) == 0:
                self._debug(f"Output CSV file is missing or empty: {output_csv}")
                print("btcposbal2csv produced no output. This may mean the chainstate is empty or the tool failed.")
                return False
            
            # Load the CSV file
            # Try different common column names
            success = False
            for addr_col, bal_col in [
                ('address', 'balance'),
                ('Address', 'Balance'),
                ('addr', 'bal'),
                ('address', 'amount'),
            ]:
                if self.load_from_csv(output_csv, addr_col, bal_col):
                    success = True
                    break
            
            if not success:
                # Try loading with just addresses (no balance column)
                self._debug("Trying to load CSV without balance column...")
                if self.load_from_csv(output_csv, 'address', 'nonexistent'):
                    success = True
            
            return success
            
        except subprocess.TimeoutExpired:
            self._debug("btcposbal2csv timed out after 10 minutes")
            print("btcposbal2csv extraction timed out. The chainstate may be very large.")
            return False
        except Exception as e:
            self._debug(f"Error during btcposbal2csv extraction: {e}")
            print(f"Failed to extract addresses: {e}")
            return False
        finally:
            # Clean up temporary file if we created one
            if temp_file is not None and os.path.exists(output_csv):
                try:
                    os.unlink(output_csv)
                    self._debug(f"Cleaned up temporary file: {output_csv}")
                except Exception:
                    pass

    def get_bitcoin_core_db_paths(self) -> List[str]:
        """Get all plausible Bitcoin Core chainstate LevelDB paths on this machine."""
        home = os.path.expanduser("~")
        appdata = os.environ.get('APPDATA')

        base_dirs = [
            # Linux custom (per-user)
            os.path.join(home, "Desktop", "blockchain", "chainstate"),
            # Linux custom (per-user)
            os.path.join(home, "Desktop", "blockchain"),
            # Linux snap install (per-user)
            os.path.join(home, "snap", "bitcoin-core", "common", ".bitcoin"),
            # Linux snap install (system-wide daemon)
            os.path.join(os.sep, "var", "snap", "bitcoin-core", "common", ".bitcoin"),
            # Linux standard
            os.path.join(home, ".bitcoin"),
            # macOS
            os.path.join(home, "Library", "Application Support", "Bitcoin"),
        ]
        if appdata:
            # Windows
            base_dirs.append(os.path.join(appdata, "Bitcoin"))

        network_subdirs = ["", "testnet3", "signet", "regtest"]

        candidates: List[str] = []
        for base in base_dirs:
            for net in network_subdirs:
                chainstate_dir = os.path.join(base, net, "chainstate") if net else os.path.join(base, "chainstate")
                if os.path.exists(chainstate_dir):
                    candidates.append(chainstate_dir)

        return candidates

    def get_bitcoin_core_db_path(self) -> str:
        """Get the default Bitcoin Core chainstate LevelDB path."""
        candidates = self.get_bitcoin_core_db_paths()
        if candidates:
            return candidates[0]

        # Fallback path (likely to fail, but consistent with previous behavior)
        home = os.path.expanduser("~")
        return os.path.join(home, "snap", "bitcoin-core", "common", ".bitcoin", "chainstate")

    def _parse_compact_size(self, data, offset):
        """Parse Bitcoin's compact size (varint) format"""
        if offset >= len(data):
            return 0, offset
        
        first_byte = data[offset]
        if first_byte < 0xfd:
            return first_byte, offset + 1
        elif first_byte == 0xfd:
            if offset + 3 > len(data):
                return 0, offset
            return struct.unpack('<H', data[offset+1:offset+3])[0], offset + 3
        elif first_byte == 0xfe:
            if offset + 5 > len(data):
                return 0, offset
            return struct.unpack('<I', data[offset+1:offset+5])[0], offset + 5
        else:
            if offset + 9 > len(data):
                return 0, offset
            return struct.unpack('<Q', data[offset+1:offset+9])[0], offset + 9

    def _decode_varint_amount(self, data, offset):
        """Decode Bitcoin's variable-length amount encoding"""
        if offset >= len(data):
            return 0, offset
        
        n = data[offset]
        offset += 1
        
        if n < 0xfd:
            return n, offset
        elif n == 0xfd:
            if offset + 2 > len(data):
                return 0, offset
            return struct.unpack('<H', data[offset:offset+2])[0], offset + 2
        elif n == 0xfe:
            if offset + 4 > len(data):
                return 0, offset
            return struct.unpack('<I', data[offset:offset+4])[0], offset + 4
        else:
            if offset + 8 > len(data):
                return 0, offset
            return struct.unpack('<Q', data[offset:offset+8])[0], offset + 8

    def _decode_compressed_amount(self, data, offset):
        """
        Decode Bitcoin Core's compressed amount format (CTxOutCompressor).

        Based on Bitcoin Core's compressor.h implementation:
        - CompressAmount removes trailing zeros and encodes the mantissa
        - DecompressAmount reverses this process

        The algorithm stores amounts in a compressed format that optimizes
        for common satoshi values (ending in zeros).
        """
        if offset >= len(data):
            return 0, offset

        # Read the varint that encodes the compressed amount
        n = data[offset]
        offset += 1

        if n < 0xfd:
            xn = n
        elif n == 0xfd:
            if offset + 2 > len(data):
                return 0, offset
            xn = struct.unpack('<H', data[offset:offset+2])[0]
            offset += 2
        elif n == 0xfe:
            if offset + 4 > len(data):
                return 0, offset
            xn = struct.unpack('<I', data[offset:offset+4])[0]
            offset += 4
        else:
            if offset + 8 > len(data):
                return 0, offset
            xn = struct.unpack('<Q', data[offset:offset+8])[0]
            offset += 8

        # Decompress using Bitcoin Core's algorithm
        # From compressor.h: uint64_t DecompressAmount(uint64_t x)
        if xn == 0:
            return 0, offset

        xn -= 1  # Subtract 1 (encoding adds 1)
        e = xn % 10  # Extract the exponent (number of trailing zeros)
        xn //= 10

        n = 0
        if e < 9:
            # Decode mantissa: (x % 9) gives digit (1-9)
            d = (xn % 9) + 1
            xn //= 9
            n = xn * 10 + d
        else:
            # e == 9 means large amounts
            n = xn + 1

        # Add back trailing zeros
        while e > 0:
            n *= 10
            e -= 1

        return n, offset

    def _extract_address_from_script(self, script, network: Optional[str] = None):
        """
        Extract Bitcoin address from scriptPubKey.
        
        Args:
            script: The scriptPubKey bytes
            network: Network name ('mainnet', 'testnet', 'regtest', 'signet').
                    If None, uses self.network (default: mainnet).
        
        Returns:
            Bitcoin address as string, or None if script is not recognized
        """
        if len(script) < 1:
            return None
        
        # Get network configuration
        if network is None:
            network = self.network
        if network not in NETWORKS:
            network = 'mainnet'
        
        net_config = NETWORKS[network]
        
        # P2PKH (Pay to Public Key Hash)
        # script: OP_DUP OP_HASH160 <hash> OP_EQUALVERIFY OP_CHECKSIG
        # bytes: 76 a9 14 <20 bytes> 88 ac
        if (len(script) == 25 and script[0] == 0x76 and script[1] == 0xa9 and 
            script[2] == 0x14 and script[23] == 0x88 and script[24] == 0xac):
            pubkey_hash = script[3:23]
            return base58check_encode(net_config['p2pkh_version'], pubkey_hash)
        
        # P2SH (Pay to Script Hash)
        # script: OP_HASH160 <hash> OP_EQUAL
        # bytes: a9 14 <20 bytes> 87
        if (len(script) == 23 and script[0] == 0xa9 and script[1] == 0x14 and 
            script[22] == 0x87):
            script_hash = script[2:22]
            return base58check_encode(net_config['p2sh_version'], script_hash)
        
        # P2WPKH (Pay to Witness Public Key Hash)
        # script: OP_0 <20-byte hash>
        # bytes: 00 14 <20 bytes>
        if (len(script) == 22 and script[0] == 0x00 and script[1] == 0x14):
            witness_program = script[2:22]
            return bech32_encode(net_config['bech32_hrp'], 0, list(witness_program))
        
        # P2WSH (Pay to Witness Script Hash)
        # script: OP_0 <32-byte hash>
        # bytes: 00 20 <32 bytes>
        if (len(script) == 34 and script[0] == 0x00 and script[1] == 0x20):
            witness_program = script[2:34]
            return bech32_encode(net_config['bech32_hrp'], 0, list(witness_program))
        
        # P2TR (Taproot)
        # script: OP_1 <32-byte program>
        if (len(script) == 34 and script[0] == 0x51 and script[1] == 0x20):
            witness_program = script[2:34]
            return bech32_encode(net_config['bech32_hrp'], 1, list(witness_program))
        
        return None

    def load_from_bitcoin_core(self, path=None):
        """Load balance data from Bitcoin Core chainstate LevelDB."""
        try:
            import plyvel
            self._debug("plyvel library imported successfully")
        except ImportError:
            self._debug("ERROR: plyvel is not installed")
            print("plyvel is not installed. Install it with: pip install plyvel")
            return False
        
        auto_detected = path is None

        if auto_detected:
            candidate_paths = self.get_bitcoin_core_db_paths()
            if not candidate_paths:
                candidate_paths = [self.get_bitcoin_core_db_path()]
            self._debug(f"No path specified, found {len(candidate_paths)} candidate chainstate path(s)")
            for i, candidate in enumerate(candidate_paths[:10], start=1):
                self._debug(f"  Candidate {i}: {candidate}")
        else:
            candidate_paths = [path]
            self._debug(f"Using specified path: {path}")

        if not auto_detected and (path is None or not os.path.exists(path)):
            self._debug(f"ERROR: Bitcoin Core chainstate not found at: {path}")
            self._debug(f"Directory exists: {os.path.exists(os.path.dirname(path))}")
            self._debug(
                f"Contents of parent directory: {os.listdir(os.path.dirname(path)) if os.path.exists(os.path.dirname(path)) else 'N/A'}"
            )
            print(f"Bitcoin Core chainstate not found at: {path}")
            return False

        try:
            # Open the chainstate LevelDB
            db = None
            selected_path = None
            fallback_db = None
            fallback_path = None

            for candidate_path in candidate_paths:
                if not os.path.exists(candidate_path):
                    continue

                try:
                    self._debug(f"Attempting to open LevelDB at: {candidate_path}")
                    candidate_db = plyvel.DB(candidate_path, create_if_missing=False, compression=None)
                except Exception as db_error:
                    error_msg = str(db_error)
                    self._debug(f"ERROR: Failed to open DB at {candidate_path}: {error_msg}")
                    if 'lock' in error_msg.lower() or 'already held' in error_msg.lower():
                        print(f"Failed to load Bitcoin Core DB: {db_error}")
                        print("The chainstate database is locked by another process (likely Bitcoin Core).")
                        print("Please close Bitcoin Core and try again, or use a file-based address list instead.")
                        return False
                    if not auto_detected:
                        print(f"Failed to open Bitcoin Core DB: {db_error}")
                        return False
                    continue

                if not auto_detected:
                    db = candidate_db
                    selected_path = candidate_path
                    break

                # When auto-detecting, prefer a chainstate that actually contains UTXO entries ('C' keys).
                has_utxos = False
                it = None
                try:
                    it = candidate_db.iterator(prefix=b'C')
                    for _k, _v in it:
                        has_utxos = True
                        break
                finally:
                    if it is not None:
                        it.close()

                if has_utxos:
                    if fallback_db is not None:
                        fallback_db.close()
                    db = candidate_db
                    selected_path = candidate_path
                    self._debug(f"Selected chainstate path (UTXO entries present): {candidate_path}")
                    break

                if fallback_db is None:
                    fallback_db = candidate_db
                    fallback_path = candidate_path
                else:
                    candidate_db.close()

            if db is None and fallback_db is not None:
                db = fallback_db
                selected_path = fallback_path
                self._debug(f"Selected chainstate path (no UTXO entries detected in other candidates): {selected_path}")

            if db is None or selected_path is None:
                print("Bitcoin Core chainstate not found at any known location")
                return False

            path = selected_path
            self._debug(f"Chainstate directory found at: {path}")
            self._debug(f"Directory contents: {os.listdir(path) if os.path.isdir(path) else 'Not a directory'}")
            self._debug("Successfully opened LevelDB connection")
            
            # Detect network from path
            self.network = detect_network_from_path(path)
            self._debug(f"Detected network: {self.network}")
            
            # Iterate through all entries in the database
            address_balances = {}
            total_utxos = 0
            utxo_entries_seen = 0
            processed_entries = 0
            skipped_entries = 0
            
            self._debug("Starting to iterate through LevelDB entries...")
            
            for key, value in db:
                processed_entries += 1
                key_prefix = key[0] if len(key) > 0 else None
                key_prefix_hex = f"0x{key_prefix:02x}" if key_prefix is not None else "empty"
                key_prefix_chr = (
                    chr(key_prefix)
                    if key_prefix is not None and 32 <= key_prefix <= 126
                    else None
                )
                key_prefix_display = (
                    key_prefix_hex
                    if key_prefix_chr is None
                    else f"{key_prefix_hex} ('{key_prefix_chr}')"
                )

                if key_prefix is None or key_prefix != ord('C'):
                    skipped_entries += 1
                    if processed_entries <= 100:  # Log first 100 entries for debugging
                        self._debug(
                            f"Skipping entry {processed_entries}: key_prefix={key_prefix_display}, key_len={len(key)}, value_len={len(value)}"
                        )
                    continue

                utxo_entries_seen += 1
                self._debug(f"Processing UTXO entry {processed_entries}: key_len={len(key)}, value_len={len(value)}")

                # Parse the UTXO entry using modern Bitcoin Core CCoins format
                # Format: [version (4 bytes)] [height/coinbase flags (4 bytes)] [amount] [scriptPubKey]
                offset = 0

                # Read version (uint32)
                if offset + 4 > len(value):
                    self._debug(f"Skipping: value too short for version field (len={len(value)})")
                    continue
                version = struct.unpack('<I', value[offset:offset+4])[0]
                self._debug(f"  Version: {version}")
                offset += 4

                # Read height and coinbase flags (uint32, but bit-packed)
                if offset + 4 > len(value):
                    self._debug(f"Skipping: value too short for height_flags field (offset={offset}, len={len(value)})")
                    continue
                height_flags = struct.unpack('<I', value[offset:offset+4])[0]
                height = height_flags >> 1  # High bits are block height
                is_coinbase = height_flags & 1  # Low bit is coinbase flag
                self._debug(f"  Height: {height}, Coinbase: {is_coinbase}")
                offset += 4

                # Decode amount using Bitcoin Core's compressed format
                try:
                    amount, offset = self._decode_compressed_amount(value, offset)
                    self._debug(f"  Amount: {amount} satoshis")
                except Exception as e:
                    self._debug(f"Skipping: Failed to decode amount: {e}")
                    continue

                # Decode scriptPubKey size
                try:
                    script_size, offset = self._parse_compact_size(value, offset)
                    self._debug(f"  Script size: {script_size}")
                except Exception as e:
                    self._debug(f"Skipping: Failed to parse script size: {e}")
                    continue

                # Extract scriptPubKey
                if offset + script_size > len(value):
                    self._debug(f"Skipping: script extends beyond value bounds (offset={offset}, script_size={script_size}, value_len={len(value)})")
                    continue

                script_pubkey = value[offset:offset+script_size]
                self._debug(f"  Script: {script_pubkey.hex()}")

                # Extract address from script
                address = self._extract_address_from_script(script_pubkey)
                self._debug(f"  Extracted address: {address}")

                if address:
                    if address in address_balances:
                        address_balances[address] += amount
                    else:
                        address_balances[address] = amount
                    total_utxos += 1
                    self._debug(f"  Added/updated address in balances: {address}")
            
            db.close()
            
            self._debug(f"Total entries processed: {processed_entries}")
            self._debug(f"Skipped entries (non-UTXO): {skipped_entries}")
            self._debug(f"UTXO entries encountered: {utxo_entries_seen}")
            self._debug(f"UTXO entries with addresses: {total_utxos}")
            self._debug(f"Unique addresses extracted: {len(address_balances)}")

            if not address_balances:
                print("No addresses found in Bitcoin Core data")
                self._debug("No addresses could be extracted from the chainstate data")

                if utxo_entries_seen == 0:
                    self._debug("No UTXO entries ('C' keys) were found in this chainstate database")
                    self._debug("This usually means:")
                    self._debug("  - Bitcoin Core is still in 'headers-first' sync - it has downloaded")
                    self._debug("    block headers but hasn't validated and committed UTXO entries yet")
                    self._debug("  - The blockchain sync is at ~10% as you mentioned - Bitcoin Core")
                    self._debug("    needs to fully validate blocks before adding to chainstate")
                    self._debug("  - You're using testnet/signet/regtest but reading the mainnet chainstate")
                    self._debug("  - Snap: the synced data may be under /var/snap/bitcoin-core/common/.bitcoin")
                    self._debug("")
                    self._debug("The chainstate only contains UTXOs from FULLY VALIDATED blocks.")
                    self._debug("You need to wait for Bitcoin Core to sync more blocks, OR:")
                    self._debug("  1. Use a pre-synced Bitcoin Core node on another machine")
                    self._debug("  2. Export funded addresses from Bitcoin Core using RPC:")
                    self._debug("     bitcoin-cli listunspent > addresses.txt")
                    self._debug("  3. Use the 'Load Funded Addresses File' option instead")
                else:
                    self._debug("This could mean:")
                    self._debug("  - The blockchain is not fully synced")
                    self._debug("  - The UTXO entries don't contain recognizable address formats")
                    self._debug("  - The chainstate file format is incompatible")

                return False
            
            self.address_balances = address_balances
            self.data_path = path
            self.is_loaded = True
            
            print(f"Loaded {len(address_balances)} addresses from {total_utxos} UTXOs")
            return True
            
        except Exception as e:
            self._debug(f"ERROR: Exception during load: {e}")
            print(f"Failed to load Bitcoin Core DB: {e}")
            import traceback
            traceback.print_exc()
            return False

    def check_balance(self, address):
        """Check if an address has a non-zero balance"""
        if not self.is_loaded:
            return 0
        
        # Check against loaded address file
        if self.funded_addresses:
            return 1 if address in self.funded_addresses else 0
        
        # Check against Bitcoin Core chainstate
        if self.address_balances:
            balance = self.address_balances.get(address, 0)
            return balance
        
        return 0

    def get_balance(self, address):
        """Get the exact balance for an address (in satoshis)"""
        if not self.is_loaded:
            return 0
        
        if self.funded_addresses:
            return 1 if address in self.funded_addresses else 0
        
        if self.address_balances:
            return self.address_balances.get(address, 0)
        
        return 0

    def check_balance_and_membership(self, address):
        """
        Check both balance and membership in funded list.
        
        Returns:
            tuple: (balance, is_in_funded_list) where balance is in satoshis
                   and is_in_funded_list is a boolean
        """
        if not self.is_loaded:
            return 0, False
        
        # Check against loaded address file (this is the funded list)
        if self.funded_addresses:
            is_member = address in self.funded_addresses
            return 1 if is_member else 0, is_member
        
        # Check against Bitcoin Core chainstate or CSV
        if self.address_balances:
            balance = self.address_balances.get(address, 0)
            is_member = balance > 0
            return balance, is_member
        
        return 0, False

    def get_status(self):
        """Get status message"""
        if self.is_loaded:
            if self.funded_addresses:
                return f"Loaded {len(self.funded_addresses)} funded addresses from file"
            if self.address_balances:
                return f"Loaded {len(self.address_balances)} addresses from Bitcoin Core chainstate"
            if self.data_path:
                return f"Connected to Bitcoin Core data: {os.path.basename(self.data_path)}"
        return "Balance checking not active"

    def close(self):
        """Clean up resources"""
        if self.db:
            self.db.close()
            self.db = None

    def create_bloom_filter(self, addresses=None, num_hashes=7, bits_per_item=10):
        """
        Create a bloom filter for GPU-accelerated balance checking.

        A bloom filter is a space-efficient probabilistic data structure
        that can test whether an element is a member of a set. False positives
        are possible, but false negatives are not. This makes it perfect for
        GPU-side filtering - addresses that don't match the bloom filter
        can be safely skipped, while matches need CPU verification.

        The bloom filter is computed from the hash160 (first 20 bytes) of each
        address for efficient GPU comparison.

        Args:
            addresses: List of addresses to include in filter.
                      If None, uses self.funded_addresses or self.address_balances keys.
            num_hashes: Number of hash functions to use (default: 7)
            bits_per_item: Bits to allocate per item (default: 10, gives ~1% false positive rate)

        Returns:
            tuple: (bloom_filter_bytes, num_bits) where bloom_filter_bytes is a bytes object
                   containing the filter data, and num_bits is the total bits in the filter.
                   Returns (None, None) if no addresses available.

        Example:
            >>> checker.load_addresses('funded.txt')
            >>> filter_data, num_bits = checker.create_bloom_filter()
            >>> # Send filter_data to GPU for fast balance checking
        """
        # Get addresses to include
        if addresses is None:
            if self.funded_addresses:
                addresses = list(self.funded_addresses)
            elif self.address_balances:
                addresses = list(self.address_balances.keys())
            else:
                print("No addresses loaded for bloom filter creation")
                return None, None

        if not addresses:
            print("Empty address list for bloom filter creation")
            return None, None

        # Calculate filter size
        num_items = len(addresses)

        # Sanity check: limit bloom filter size to prevent memory exhaustion
        # For large address sets, cap at 1GB (8 billion bits) to prevent system lockup
        max_byte_size = 1024 * 1024 * 1024  # 1GB max
        num_bits = num_items * bits_per_item
        byte_size = (num_bits + 7) // 8

        if byte_size > max_byte_size:
            print(f"WARNING: Bloom filter would be too large ({byte_size / (1024**3):.2f} GB)")
            print(f"Reducing bits_per_item from {bits_per_item} to {max_byte_size * 8 // num_items}")
            num_bits = max_byte_size * 8
            byte_size = max_byte_size

        # Initialize bloom filter
        bloom_filter = bytearray(byte_size)

        # For each address, compute hash160 and set bits
        for addr in addresses:
            # Compute hash160 of address (for GPU compatibility)
            # We'll use the raw bytes to determine which bits to set
            addr_bytes = addr.encode('ascii') if isinstance(addr, str) else addr

            # Create a simple hash from the address
            h1 = 0
            h2 = 0
            for i, b in enumerate(addr_bytes):
                h1 = ((h1 * 31) + b) & 0xFFFFFFFF
                h2 = ((h2 * 31) + b) ^ (h1 << 7) & 0xFFFFFFFF

            # Set bits using multiple hash functions
            for i in range(num_hashes):
                bit_idx = (h1 + i * h2) % num_bits
                bloom_filter[bit_idx // 8] |= (1 << (bit_idx % 8))

        print(f"Created bloom filter with {byte_size} bytes ({num_bits} bits) for {num_items} addresses")
        print(f"Expected false positive rate: ~{0.5 ** num_hashes * 100:.2f}%")

        return bytes(bloom_filter), num_bits

    def create_gpu_address_buffer(self, addresses=None):
        """
        Create a GPU-compatible buffer of address hash160 values for verification.

        This creates a compact binary representation of addresses that can be
        transferred to GPU memory for exact matching after bloom filter pre-filtering.

        Args:
            addresses: List of addresses to include. If None, uses all loaded addresses.

        Returns:
            bytes: Binary buffer containing (hash160, address_string) pairs.
                   Returns None if no addresses available.

        Buffer format:
            For each address (64 bytes total):
            - First 20 bytes: hash160 of address
            - Next 34 bytes: address string (null-padded)
            - Next 10 bytes: reserved/alignment
        """
        # Get addresses
        if addresses is None:
            if self.funded_addresses:
                addresses = list(self.funded_addresses)
            elif self.address_balances:
                addresses = list(self.address_balances.keys())
            else:
                return None

        if not addresses:
            return None

        # Sanity check: limit buffer size to prevent memory exhaustion
        buffer_size = 64 * len(addresses)
        max_buffer_size = 512 * 1024 * 1024  # 512MB max for address buffer

        if buffer_size > max_buffer_size:
            print(f"WARNING: Address buffer would be too large ({buffer_size / (1024**2):.2f} MB)")
            print(f"Limiting to first {max_buffer_size // 64} addresses")
            addresses = addresses[:max_buffer_size // 64]
            buffer_size = 64 * len(addresses)

        # Import hash160 for computing address hashes
        try:
            from .crypto_utils import hash160 as py_hash160
        except ImportError:
            from crypto_utils import hash160 as py_hash160

        # Build buffer
        buffer = bytearray(buffer_size)
        for i, addr in enumerate(addresses):
            offset = i * 64

            # Compute hash160 of address for GPU matching
            addr_bytes = addr.encode('ascii')
            addr_hash = py_hash160(addr_bytes)

            # Store hash160 (20 bytes)
            buffer[offset:offset+20] = addr_hash

            # Store address string (34 bytes, null-padded)
            addr_bytes_padded = addr_bytes.ljust(34, b'\x00')
            buffer[offset+20:offset+54] = addr_bytes_padded

        return bytes(buffer)
